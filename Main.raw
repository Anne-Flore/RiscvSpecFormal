
module Main where

import Simulator.All
import HaskellTarget as T

import Control.Monad
import Data.IORef
import System.Exit
import System.IO

handle :: Handle
handle = stdout

timeout :: Int
timeout = 50000

isa_size :: Int
isa_size = snd T.kami_model

regfiles :: [T.RegFileBase]
regfiles = fst $ fst T.kami_model

basemod :: T.BaseModule
basemod = snd $ fst T.kami_model

meths :: IORef Int -> [(String, Val -> IO Val)]
meths counter = [("proc_core_pc", proc_core_meth counter)]

proc_core_meth :: IORef Int -> Val -> IO Val
proc_core_meth counter v = do
    passaddr <- getPass isa_size
    failaddr <- getFail isa_size
    n <- readIORef counter
    when (n > timeout) $ do
        hPutStrLn handle "TIMEDOUT TIMEDOUT TIMEDOUT TIMEDOUT TIMEDOUT TIMEDOUT"
        hPutStrLn stderr "TIMEDOUT TIMEDOUT TIMEDOUT TIMEDOUT TIMEDOUT TIMEDOUT"
        exitFailure
    writeIORef counter (n+1)
    if v == passaddr then do
        hPutStrLn handle "Passed"
        hPutStrLn stderr "Passed"
        exitSuccess
    else if Just v == failaddr then do
        hPutStrLn handle "FAILED FAILED FAILED FAILED FAILED FAILED FAILED FAILED FAILED"
        hPutStrLn stderr "FAILED FAILED FAILED FAILED FAILED FAILED FAILED FAILED FAILED"
        exitFailure
    else return tt

main :: IO()
main = do
    counter <- newIORef 0
    simulate_module 0 round_robin_rules (map fst $ T.getRules basemod) (meths counter) regfiles basemod
    return ()
